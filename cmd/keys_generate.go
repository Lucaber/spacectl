package cmd

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"fmt"
	"github.com/mittwald/spacectl/view"
	"github.com/spf13/cobra"
	"golang.org/x/crypto/ssh"
	"os"
	"github.com/fatih/color"
	"os/user"
)

var keyGenerateFlags struct {
	lengthBit int
	comment   string
	force     bool
	file      string
}

var keyGenerateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generates and imports a new SSH public key",
	Long:  `This command generates and imports a new SSH public key`,
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Printf("Generating RSA key-pair with a length of %d bits...", keyGenerateFlags.lengthBit)
		privateKey, err := rsa.GenerateKey(rand.Reader, keyGenerateFlags.lengthBit)
		if err != nil {
			return fmt.Errorf("Could not generate RSA private key: %s", err)
		}
		fmt.Printf(" done.\n")

		privateKeyX509 := x509.MarshalPKCS1PrivateKey(privateKey)
		privateKeyBlock := pem.Block{
			Type:    "RSA PRIVATE KEY",
			Headers: nil,
			Bytes:   privateKeyX509,
		}

		_, err = os.Stat(keyGenerateFlags.file)
		if err == nil {
			if keyGenerateFlags.force {
				fmt.Printf("Output file %s already exists. Overwriting file.\n", color.YellowString(keyGenerateFlags.file))
			} else {
				return fmt.Errorf("Output file %s already exists. Use the -f or --force flag to overwrite.", keyGenerateFlags.file)
			}
		} else if os.IsNotExist(err) {
			fmt.Printf("Writing to output file %s.\n", color.YellowString(keyGenerateFlags.file))
		} else {
			return fmt.Errorf("Error while stat'ing %s: %s", keyGenerateFlags.file, err)
		}

		privateKeyOutputFile, err := os.Create(keyGenerateFlags.file)
		if err != nil {
			return fmt.Errorf("Could not open %s for writing: %s", keyGenerateFlags.file, err)
		}

		publicKeyOutputFile, err := os.Create(keyGenerateFlags.file + ".pub")
		if err != nil {
			return fmt.Errorf("Could not open %s for writing: %s", keyGenerateFlags.file + ".pub", err)
		}

		publicKey := privateKey.PublicKey
		publicKeySSH, err := ssh.NewPublicKey(&publicKey)
		if err != nil {
			return fmt.Errorf("Could not generate SSH public key: %s", err)
		}

		publicKeyBase64 := base64.StdEncoding.EncodeToString(publicKeySSH.Marshal())

		pem.Encode(privateKeyOutputFile, &privateKeyBlock)
		fmt.Fprintf(publicKeyOutputFile, "%s %s %s\n", publicKeySSH.Type(), publicKeyBase64, keyGenerateFlags.comment)

		createdKey, err := api.SSHKeys().Add(publicKeySSH.Marshal(), publicKeySSH.Type(), keyGenerateFlags.comment)
		if err != nil {
			return err
		}

		v := view.TabularKeyDetailView{}
		v.KeyDetail(createdKey, os.Stdout)

		return nil
	},
}

func init() {
	keysCmd.AddCommand(keyGenerateCmd)

	u, _ := user.Current()

	f := keyGenerateCmd.Flags()
	f.StringVarP(&keyGenerateFlags.comment, "comment", "c", "auto-generated by spacectl", "Key comment")
	f.IntVarP(&keyGenerateFlags.lengthBit, "length", "b", 4096, "Private key length in bit")
	f.BoolVarP(&keyGenerateFlags.force, "force", "f", false, "Overwrite output file when it already exists")
	f.StringVarP(&keyGenerateFlags.file, "output", "o", u.HomeDir + "/.ssh/spaces", "Output file in which the generated key should be stored")
}
